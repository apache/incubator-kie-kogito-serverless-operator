// Copyright 2023 Red Hat, Inc. and/or its affiliates
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package workflowproj

import (
	"fmt"
	"io"

	"github.com/pkg/errors"
	"github.com/serverlessworkflow/sdk-go/v2/model"
	"github.com/serverlessworkflow/sdk-go/v2/parser"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/client-go/kubernetes/scheme"

	"github.com/kiegroup/kogito-serverless-operator/api/metadata"
	operatorapi "github.com/kiegroup/kogito-serverless-operator/api/v1alpha08"
)

var _ WorkflowProjectHandler = &workflowProjectHandler{}

// WorkflowProjectHandler is the description of the handler interface.
// A handler can generate Kubernetes manifests to deploy a new Kogito Serverless Workflow project in the cluster
type WorkflowProjectHandler interface {
	// Named overwrites the workflow ID. The handler will use this name instead to generate the manifests name.
	// Remember that together with the Namespace, the Name is the unique key of a Kubernetes object.
	Named(name string) WorkflowProjectHandler
	// WithWorkflow reader for a file or the content stream of a workflow definition.
	WithWorkflow(reader io.Reader) WorkflowProjectHandler
	// WithAppProperties reader for a file or the content stream of a workflow application properties.
	WithAppProperties(reader io.Reader) WorkflowProjectHandler
	// AddResource reader for a file or the content stream of any resource needed by the workflow. E.g. an OpenAPI specification file.
	// Name is required, should match the workflow function definition.
	// The handler will try to guess the file type using json schema validations.
	// Guessing the file type can be resource intensive in some CPUs. If you mind processing power, use AddResourceTyped instead.
	AddResource(name string, reader io.Reader) WorkflowProjectHandler
	// AddResourceTyped see AddResource. But enforce the resource type (e.g. OpenAPI spec file).
	AddResourceTyped(name string, reader io.Reader, resourceType metadata.ExtResType) WorkflowProjectHandler
	// SaveAsKubernetesManifests saves the project in the given file system path in YAML format.
	SaveAsKubernetesManifests(path string) error
	// AsObjects returns a reference to the WorkflowProject holding the Kubernetes Manifests based on your files.
	AsObjects() (*WorkflowProject, error)
}

// WorkflowProject is a structure to hold every Kubernetes object generated by the given WorkflowProjectHandler handler.
type WorkflowProject struct {
	// Workflow the workflow definition
	Workflow *operatorapi.KogitoServerlessWorkflow
	// Properties the application properties for the workflow
	Properties *corev1.ConfigMap
	// Resources any resource that this workflow requires, like an OpenAPI specification file.
	Resources []*corev1.ConfigMap
}

type resource struct {
	name     string
	contents io.Reader
	kind     metadata.ExtResType
}

// New is the entry point for this package.
// You can create a new handler with the given namespace, meaning that every manifest generated will use this namespace.
// namespace is a required parameter.
func New(namespace string) WorkflowProjectHandler {
	s := scheme.Scheme
	utilruntime.Must(operatorapi.AddToScheme(s))
	utilruntime.Must(corev1.AddToScheme(s))
	return &workflowProjectHandler{
		scheme:    s,
		namespace: namespace,
	}
}

type workflowProjectHandler struct {
	name             string
	namespace        string
	scheme           *runtime.Scheme
	project          WorkflowProject
	rawWorkflow      io.Reader
	rawAppProperties io.Reader
	rawResources     []resource
	parsed           bool
}

func (w *workflowProjectHandler) Named(name string) WorkflowProjectHandler {
	w.name = name
	w.parsed = false
	return w
}

func (w *workflowProjectHandler) WithWorkflow(reader io.Reader) WorkflowProjectHandler {
	w.rawWorkflow = reader
	w.parsed = false
	return w
}

func (w *workflowProjectHandler) WithAppProperties(reader io.Reader) WorkflowProjectHandler {
	w.rawAppProperties = reader
	w.parsed = false
	return w
}

func (w *workflowProjectHandler) AddResource(name string, reader io.Reader) WorkflowProjectHandler {
	for _, r := range w.rawResources {
		if r.name == name {
			r.contents = reader
			return w
		}
	}
	w.rawResources = append(w.rawResources, resource{name: name, contents: reader})
	w.parsed = false
	return w
}

func (w *workflowProjectHandler) AddResourceTyped(name string, reader io.Reader, kind metadata.ExtResType) WorkflowProjectHandler {
	for _, r := range w.rawResources {
		if r.name == name && r.kind == kind {
			r.contents = reader
			return w
		}
	}
	w.rawResources = append(w.rawResources, resource{name: name, contents: reader, kind: kind})
	w.parsed = false
	return w
}

func (w *workflowProjectHandler) SaveAsKubernetesManifests(path string) error {
	if err := ensurePath(path); err != nil {
		return err
	}
	if err := w.parseRawProject(); err != nil {
		return err
	}
	fileCount := 1
	if err := saveAsKubernetesManifest(w.project.Workflow, path, fmt.Sprintf("%02d_", 1)); err != nil {
		return err
	}
	for i, r := range w.project.Resources {
		fileCount = i + 1
		if err := saveAsKubernetesManifest(r, path, fmt.Sprintf("%02d_", fileCount)); err != nil {
			return err
		}
	}
	fileCount++
	if err := saveAsKubernetesManifest(w.project.Properties, path, fmt.Sprintf("%02d_", fileCount)); err != nil {
		return err
	}
	return nil
}

func (w *workflowProjectHandler) AsObjects() (*WorkflowProject, error) {
	if err := w.parseRawProject(); err != nil {
		return nil, err
	}
	return &w.project, nil
}

func (w *workflowProjectHandler) parseRawProject() error {
	if w.parsed {
		return nil
	}
	if err := w.sanityCheck(); err != nil {
		return err
	}
	if err := w.parseRawWorkflow(); err != nil {
		return err
	}
	if err := w.parseRawAppProperties(); err != nil {
		return err
	}
	if err := w.parseRawResources(); err != nil {
		return err
	}
	w.parsed = true
	return nil
}

func (w *workflowProjectHandler) sanityCheck() error {
	if len(w.namespace) == 0 {
		return errors.New("Namespace is required when building Workflow projects")
	}
	if w.rawWorkflow == nil {
		return errors.New("A workflow reader pointer is required when building Workflow projects")
	}
	return nil
}

func (w *workflowProjectHandler) parseRawWorkflow() error {
	workflowContents, err := io.ReadAll(w.rawWorkflow)
	if err != nil {
		return err
	}
	var workflowDef *model.Workflow
	// TODO: add this to the SDK, also an input from io.Reader
	workflowDef, err = parser.FromJSONSource(workflowContents)
	if err != nil {
		workflowDef, err = parser.FromYAMLSource(workflowContents)
		if err != nil {
			return errors.Errorf("Failed to parse the workflow either as a JSON or as a YAML file: %+v", err)
		}
	}

	if len(w.name) == 0 {
		w.name = workflowDef.ID
	}

	w.project.Workflow = &operatorapi.KogitoServerlessWorkflow{
		ObjectMeta: metav1.ObjectMeta{Name: w.name, Namespace: w.namespace},
		Spec:       operatorapi.KogitoServerlessWorkflowSpec{Flow: *workflowDef},
	}
	SetWorkflowProfile(w.project.Workflow, metadata.DevProfile)
	SetDefaultLabels(w.project.Workflow, w.project.Workflow)
	if err = SetTypeToObject(w.project.Workflow, w.scheme); err != nil {
		return err
	}

	return nil
}

func (w *workflowProjectHandler) parseRawAppProperties() error {
	if w.rawAppProperties == nil {
		return nil
	}
	appPropsContent, err := io.ReadAll(w.rawAppProperties)
	if err != nil {
		return err
	}
	w.project.Properties = CreateNewAppPropsConfigMap(w.project.Workflow, string(appPropsContent))
	if err = SetTypeToObject(w.project.Properties, w.scheme); err != nil {
		return err
	}
	return nil
}

func (w *workflowProjectHandler) parseRawResources() error {
	if len(w.rawResources) == 0 {
		return nil
	}
	openApiRes := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: w.name + "-openapis", Namespace: w.namespace}, Data: nil}
	asyncApiRes := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: w.name + "-asyncapis", Namespace: w.namespace}, Data: nil}
	camelRoutesRes := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: w.name + "-camelroutes", Namespace: w.namespace}, Data: nil}
	genericRes := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: w.name + "-genericres", Namespace: w.namespace}, Data: nil}

	if w.project.Workflow.Annotations == nil {
		w.project.Workflow.Annotations = map[string]string{}
	}

	for _, r := range w.rawResources {
		contents, err := io.ReadAll(r.contents)
		if err != nil {
			return err
		}
		if len(contents) == 0 {
			return errors.Errorf("Content for the resource %s is empty. Can't add an empty resource to the workflow project", r.name)
		}
		if r.kind == metadata.ExtResNone {
			r.kind = ParseResourceType(string(contents))
		}
		// collect every resource into the given configMap
		switch r.kind {
		case metadata.ExtResOpenApi:
			updateExternalResConfigMap(w.project.Workflow, r, openApiRes, string(contents))
		case metadata.ExtResAsyncApi:
			updateExternalResConfigMap(w.project.Workflow, r, asyncApiRes, string(contents))
		case metadata.ExtResCamel:
			updateExternalResConfigMap(w.project.Workflow, r, camelRoutesRes, string(contents))
		default:
			updateExternalResConfigMap(w.project.Workflow, r, genericRes, string(contents))
		}
	}

	return w.addExternalResConfigMapToProject(openApiRes, asyncApiRes, camelRoutesRes, genericRes)
}

func (w *workflowProjectHandler) addExternalResConfigMapToProject(cms ...*corev1.ConfigMap) error {
	for _, cm := range cms {
		if cm.Data != nil {
			if err := SetTypeToObject(cm, w.scheme); err != nil {
				return err
			}
			w.project.Resources = append(w.project.Resources, cm)
		}
	}
	return nil
}

func updateExternalResConfigMap(workflow *operatorapi.KogitoServerlessWorkflow, r resource, cm *corev1.ConfigMap, contents string) {
	if cm.Data == nil {
		cm.Data = map[string]string{}
	}
	cm.Data[r.name] = contents
	metadata.AddAnnotationExtResType(workflow, r.kind, cm.Name)
}
