@Library('jenkins-pipeline-shared-libraries')_

helper = null

pipeline {
    agent {
        label "rhel8 && podman && !built-in"
    }

    options {
        timeout(time: 3, unit: 'HOURS')
        timestamps()
    }

    tools {
        go 'golang-1.19'
    }

    environment {
        // Linked to node label
        CONTAINER_ENGINE='podman'
        CONTAINER_ENGINE_TLS_OPTIONS='--tls-verify=false'

        // Environment required by OLM tests when run from process
        OP_TEST_CONTAINER_OPT = '-t'
        OP_TEST_DEBUG = 1
        OP_TEST_CONTAINER_TOOL = 'docker'
    }

    stages {
        stage('Setup pipeline') {
            steps {
                script {
                    helper = load '.ci/jenkins/scripts/helper.groovy'
                    helper.initPipeline()
                }
            }
        }
        stage('Initialize') {
            steps {
                script {
                    clean()

                    helper.updateDisplayName()
                    helper.checkoutRepo()
                }
            }
        }
        stage('Run OLM tests') {
            steps {
                sh 'make olm-tests'
            }
            post {
                unsuccessful {
                    script {
                        util.archiveConsoleLog()
                    }
                }
            }
        }
    }
    post {
        cleanup {
            script {
                clean()
            }
        }
    }
}

void clean() {
    helper.cleanGoPath()
    util.cleanNode(containerEngine)
    cleanupCluster()
}

String getTestImage() {
    return params.TEST_IMAGE_FULL_TAG
}

String getClusterName() {
    return env.CLUSTER_NAME
}

String getOperatorVersion() {
    return sh(script: 'source ./hack/env.sh > /dev/null && echo $(getOperatorVersion)', returnStdout: true).trim()
}

void setupCluster() {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            setupMinikube()
            break
        case openshiftClusterPlatform:
            setupOpenshift()
            break
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot prepare for it ..."
    }
}

void setupMinikube() {
    // Start minikube
    minikube.minikubeMemory = '12g'
    minikube.start()

    minikube.waitForMinikubeStarted()
    minikube.waitForMinikubeRegistry()
}

void setupOpenshift() {
    // Login to Openshift
    openshift.loginOpenshift()
}

void cleanupCluster() {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            minikube.stop()
            break
        case openshiftClusterPlatform:
            echo 'Nothing to cleanup on openshift. All good !'
            break
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot cleanup ..."
    }
}

void executeInCluster(Closure executeClosure) {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            echo "Execute in minikube"
            executeClosure()
            break
        case openshiftClusterPlatform:
            echo "Execute in openshift"
            lock("Sonataflow Operator OpenShift tests ${getOpenshiftApi()}") {
                executeClosure()
            }
            break
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot execute anything ..."
    }
}

void getPlatformCRFilePath() {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            return 'test/testdata/sonataflow.org_v1alpha08_sonataflowplatform_withCache_minikube.yaml'
        case openshiftClusterPlatform:
            return 'test/testdata/sonataflow.org_v1alpha08_sonataflowplatform_openshift.yaml'
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot execute anything ..."
    }
}

// Special method to get the Openshift API in the lock because env is not accessible yet
void getOpenshiftApi() {
    withCredentials([string(credentialsId: env.OPENSHIFT_API_KEY, variable: 'OPENSHIFT_API')]) {
        return env.OPENSHIFT_API
    }
}
