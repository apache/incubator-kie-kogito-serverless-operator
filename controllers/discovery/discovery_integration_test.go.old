// Copyright 2023 Red Hat, Inc. and/or its affiliates
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package discovery

import (
	"context"
	"fmt"
	"github.com/apache/incubator-kie-kogito-serverless-operator/controllers/openshift"
	"testing"

	clienteventingv1 "knative.dev/eventing/pkg/client/clientset/versioned/typed/eventing/v1"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	"github.com/stretchr/testify/assert"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"

	clientservingv1 "knative.dev/serving/pkg/client/clientset/versioned/typed/serving/v1"
)

const (
	helloWorldDeployment            = "hello-world-kubernetes-quarkus-service"
	helloWorldDeploymentPod         = "hello-world-kubernetes-quarkus-service-57b845bd56-rqfl8"
	helloWorldDeploymentAddress     = "http://10.104.44.174:80"
	helloWorldServicePodSolo        = "hello-world-kubernetes-quarkus-service-pod-solo"
	helloWorldServicePodSoloAddress = "http://10.244.1.135:8080"

	helloWorldServiceServiceSolo = "hello-world-kubernetes-quarkus-service-service-solo"

	helloWorldServiceServiceSoloAddress = "http://10.101.202.245:80"

	helloWorldServiceAddress = "http://10.102.199.105:80"
)

/*
	func TestFindServiceNotExisting(t *testing.T) {
		doTestFindService(t, "usecase1", "willneverexists", "", false, "")
	}

	func TestFindPodNotExisting(t *testing.T) {
		doTestFindPod(t, "usecase1", "willneverexists", "", false, "")
	}

// we try to find for the pod, but we must get the corresponding service url

	func TestResolveHelloWorldServiceDeploymentPodUri(t *testing.T) {
		doTestFindPod(t, "usecase1", helloWorldDeploymentPod, "http", true, helloWorldDeploymentAddress)
	}

// we try to find for the service, and we must get the service url

	func TestResolveHelloWorldServiceDeploymentServiceUri(t *testing.T) {
		doTestFindService(t, "usecase1", helloWorldDeployment, "http", true, helloWorldDeploymentAddress)
	}

	func TestFindHelloWorldServicePodSolo(t *testing.T) {
		doTestFindPod(t, "usecase1", helloWorldServicePodSolo, "http", true, helloWorldServicePodSoloAddress)
	}

	func TestFindHelloWorldServicePodSoloWithServiceCreated(t *testing.T) {
		doTestFindPod(t, "usecase1", helloWorldServicePodSolo, "http", true, helloWorldServiceServiceSoloAddress)
	}

	func TestFindHelloWorldServiceServiceSolo(t *testing.T) {
		doTestFindService(t, "usecase1", helloWorldServiceServiceSolo, "http", true, helloWorldServiceServiceSoloAddress)
	}

	func TestFindServiceManual(t *testing.T) {
		doTestFindService(t, "usecase1", "hello-world-kubernetes-quarkus-service", "http", true, helloWorldServiceServiceSoloAddress)
	}

	func TestFindPodManual(t *testing.T) {
		doTestFindPod(t, "usecase1", "hello-world-kubernetes-quarkus-service-7896f8b6fc-ph62k", "http", true, helloWorldServiceAddress)
	}

	func TestFindDeploymentManual(t *testing.T) {
		doTestFindDeployment(t, "usecase1", helloWorldDeployment, "http", true, helloWorldServiceAddress)
	}

	func TestFindStatefulSetExample(t *testing.T) {
		doTestFindStatefulSet(t, "usecase1", "stateful-set-example", "http", true, helloWorldServiceAddress)
	}

	func TestFindIngressExample(t *testing.T) {
		//doTestFindIngress(t, "usecase1", "hello-world-ingress-default-backend", "http", true, helloWorldServiceAddress)
		doTestFindIngress(t, "usecase1", "simple-fanout-example", "http", true, helloWorldServiceAddress)
	}

	func doTestFindPod(t *testing.T, namespace string, name string, customPort string, shouldExist bool, expectedUri string) {
		var catalog = *createServiceCatalog(t)

		podUri, err := catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(podKind).
			Version("v1").
			Namespace(namespace).
			Name(name).
			Port(customPort).Build(),
			KubernetesDNSAddress)

		podUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(podKind).
			Version("v1").
			Namespace(namespace).
			Name(name).
			Port(customPort).Build(),
			KubernetesIPAddress)

		if shouldExist {
			assert.Nil(t, err)
			fmt.Println(fmt.Sprintf("Calculated address for pod: <%s, %s>, was %s", namespace, name, podUri))
			assert.Equal(t, expectedUri, podUri)
		} else {
			assert.NotNil(t, err)
			assert.ErrorContainsf(t, err, fmt.Sprintf("pods %q not found", name), "Test failed because the pod: <%s, %s> was not found anyway.", namespace, name)
		}
	}

	func doTestFindService(t *testing.T, namespace string, name string, customPort string, shouldExist bool, expectedUri string) {
		var catalog = *createServiceCatalog(t)

		serviceUri, err := catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(serviceKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			Port(customPort).Build(),
			KubernetesDNSAddress)

		serviceUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(serviceKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			Port(customPort).Build(),
			KubernetesIPAddress)

		if shouldExist {
			assert.Nil(t, err)
			fmt.Println(fmt.Sprintf("Calculated address for service: <%s, %s>, was %s", namespace, name, serviceUri))
			assert.Equal(t, expectedUri, serviceUri)
		} else {
			assert.NotNil(t, err)
			assert.ErrorContainsf(t, err, fmt.Sprintf("services %q not found", name), "Test failed because the service: <%s, %s> was not found anyway.", namespace, name)
		}
	}

	func doTestFindDeployment(t *testing.T, namespace string, name string, customPort string, shouldExist bool, expectedUri string) {
		var catalog = *createServiceCatalog(t)

		deploymentUri, err := catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(deploymentKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			Port(customPort).Build(),
			KubernetesDNSAddress)

		deploymentUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(deploymentKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			WithLabel("env", "development").
			Port(customPort).Build(),
			KubernetesIPAddress)

		if shouldExist {
			assert.Nil(t, err)
			fmt.Println(fmt.Sprintf("Calculated address for service: <%s, %s>, was %s", namespace, name, deploymentUri))
			assert.Equal(t, expectedUri, deploymentUri)
		} else {
			assert.NotNil(t, err)
			assert.ErrorContainsf(t, err, fmt.Sprintf("deployments %q not found", name), "Test failed because the deployment: <%s, %s> was not found anyway.", namespace, name)
		}
	}

	func doTestFindStatefulSet(t *testing.T, namespace string, name string, customPort string, shouldExist bool, expectedUri string) {
		var catalog = *createServiceCatalog(t)

		statefulSetUri, err := catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(statefulSetKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			Port(customPort).Build(),
			KubernetesDNSAddress)

		statefulSetUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(statefulSetKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			WithLabel("env", "development").
			Port(customPort).Build(),
			KubernetesIPAddress)

		if shouldExist {
			assert.Nil(t, err)
			fmt.Println(fmt.Sprintf("Calculated address for statefulset: <%s, %s>, was %s", namespace, name, statefulSetUri))
			assert.Equal(t, expectedUri, statefulSetUri)
		} else {
			assert.NotNil(t, err)
			assert.ErrorContainsf(t, err, fmt.Sprintf("statefulsets %q not found", name), "Test failed because the statefulset: <%s, %s> was not found anyway.", namespace, name)
		}
	}

	func doTestFindIngress(t *testing.T, namespace string, name string, customPort string, shouldExist bool, expectedUri string) {
		var catalog = *createServiceCatalog(t)

		statefulSetUri, err := catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(ingressKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			Port(customPort).Build(),
			KubernetesDNSAddress)

		statefulSetUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KubernetesScheme).
			Kind(ingressKind).
			Version("v1").
			Name(name).
			Namespace(namespace).
			WithLabel("env", "development").
			Port(customPort).Build(),
			KubernetesIPAddress)

		if shouldExist {
			assert.Nil(t, err)
			fmt.Println(fmt.Sprintf("Calculated address for ingress: <%s, %s>, was %s", namespace, name, statefulSetUri))
			assert.Equal(t, expectedUri, statefulSetUri)
		} else {
			assert.NotNil(t, err)
			assert.ErrorContainsf(t, err, fmt.Sprintf("intess %q not found", name), "Test failed because the ingress: <%s, %s> was not found anyway.", namespace, name)
		}
	}
*/
func createContextAndClient() (context.Context, client.Client, error) {
	cli, err := client.New(config.GetConfigOrDie(), client.Options{})
	if err != nil {
		fmt.Println("failed to create client")
		return nil, nil, err
	}
	return context.TODO(), cli, nil
}

func createContextAndServingV1Client() (context.Context, *clientservingv1.ServingV1Client, error) {
	cli, err := clientservingv1.NewForConfig(config.GetConfigOrDie())
	if err != nil {
		fmt.Println("failed to create knative client")
		return nil, nil, err
	}
	return context.TODO(), cli, nil
}

func createContextAndEventingV1Client() (context.Context, *clienteventingv1.EventingV1Client, error) {
	cli, err := clienteventingv1.NewForConfig(config.GetConfigOrDie())
	if err != nil {
		fmt.Println("failed to create knative client")
		return nil, nil, err
	}
	return context.TODO(), cli, nil
}

func createServiceCatalog(t *testing.T) *ServiceCatalog {
	var cli client.Client
	var knServingClient *clientservingv1.ServingV1Client
	var knEventingClient *clienteventingv1.EventingV1Client
	var err error

	if _, cli, err = createContextAndClient(); err != nil {
		assert.FailNow(t, "it was not possible to create the discovery client: "+err.Error())
		return nil
	}

	if _, knServingClient, err = createContextAndServingV1Client(); err != nil {
		assert.FailNow(t, "it was not possible to create the discovery client: "+err.Error())
		return nil
	}

	if _, knEventingClient, err = createContextAndEventingV1Client(); err != nil {
		assert.FailNow(t, "it was not possible to create the discovery client: "+err.Error())
		return nil
	}

	result := NewServiceCatalog(cli, newKnDiscoveryClient(knServingClient, knEventingClient), nil)
	return &result
}

func Test_queryKnativeService1(t *testing.T) {
	ctx, cli, _ := createContextAndServingV1Client()
	if service, err := cli.Services("usecase1").Get(ctx, "hello-world-knative-quarkus-service", metav1.GetOptions{}); err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(service.Name)

		url := fmt.Sprintf("%s://%s", service.Status.URL.Scheme, service.Status.URL.Host)
		fmt.Println("The route calculated: " + url)
		fmt.Println("The route toString: " + service.Status.URL.String())
	}

	ctx2, cli2, _ := createContextAndClient()
	service2 := &corev1.Service{}
	if err := cli2.Get(ctx2, types.NamespacedName{Namespace: "usecase1", Name: "hello-world-knative-quarkus-service"}, service2); err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(service2.Name)
	}
}

func Test_queryKnativeBroker1(t *testing.T) {
	ctx, cli, _ := createContextAndEventingV1Client()
	if broker, err := cli.Brokers("usecase1").Get(ctx, "hello-world-broker1", metav1.GetOptions{}); err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(broker.Name)
		fmt.Println("The route toString: " + broker.Status.Address.URL.String())
	}
}

func Test_queryKnativeService2(t *testing.T) {

	var catalog = *createServiceCatalog(t)
	var knServiceUri string
	var err error
	knServiceUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KnativeScheme).
		Kind("services").
		Group("serving.knative.dev").
		Version("v1").
		Name("hello-world-knative-quarkus-service").
		Namespace("usecase1").Build(),
		KubernetesDNSAddress)

	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(knServiceUri)
	}

	assert.Equal(t, "http://hello-world-knative-quarkus-service.usecase1.svc.cluster.local", knServiceUri)
}

func Test_queryKnativeBroker2(t *testing.T) {

	var catalog = *createServiceCatalog(t)
	var knServiceUri string
	var err error
	knServiceUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(KnativeScheme).
		Kind("brokers").
		Group("eventing.knative.dev").
		Version("v1").
		Name("hello-world-broker1").
		Namespace("usecase1").Build(),
		KubernetesDNSAddress)

	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(knServiceUri)
	}

	assert.Equal(t, "http://broker-ingress.knative-eventing.svc.cluster.local/usecase1/hello-world-broker1", knServiceUri)

}

func Test_queryOpenshiftRoute(t *testing.T) {

	var routeUri string
	var err error

	cli, err := client.New(config.GetConfigOrDie(), client.Options{})
	routeClient, err := openshift.GetRouteClient(config.GetConfigOrDie())
	assert.NoError(t, err)

	appsClient, err := openshift.GetAppsClient(config.GetConfigOrDie())
	assert.NoError(t, err)

	catalog := newOpenShiftServiceCatalog(newOpenShiftDiscoveryClient(cli, routeClient, appsClient))

	routeUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(OpenshiftScheme).
		Kind("routes").
		Group("eventing.knative.dev").
		Version("v1").
		Name("hello-world-kubernetes-quarkus-service").
		Namespace("hello-world-openshift").Build(),
		KubernetesDNSAddress)

	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(routeUri)
	}

	assert.Equal(t, "http://hello-world-kubernetes-quarkus-service-test-operator.apps-crc.testing:80", routeUri)

}

func Test_queryOpenshiftDeploymentConfig(t *testing.T) {

	var deploymentConfigUri string
	var err error

	cli, err := client.New(config.GetConfigOrDie(), client.Options{})
	routeClient, err := openshift.GetRouteClient(config.GetConfigOrDie())
	assert.NoError(t, err)

	appsClient, err := openshift.GetAppsClient(config.GetConfigOrDie())
	assert.NoError(t, err)

	catalog := newOpenShiftServiceCatalog(newOpenShiftDiscoveryClient(cli, routeClient, appsClient))

	deploymentConfigUri, err = catalog.Query(context.TODO(), *NewResourceUriBuilder(OpenshiftScheme).
		Kind("deploymentconfigs").
		Group("apps.openshift.io").
		Version("v1").
		Name("hello-world-openshift-quarkus-service").
		Namespace("hello-world-openshift").
		WithQueryParam("param1", "value1").
		WithQueryParam("param2", "value2").
		WithPort("http").
		Build(),
		KubernetesDNSAddress)

	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(deploymentConfigUri)
	}

	assert.Equal(t, "http://hello-world-openshift-quarkus-service.hello-world-openshift.svc:80", deploymentConfigUri)

}
